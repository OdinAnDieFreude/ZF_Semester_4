\documentclass[10pt]{article}
%Gummi|065|=)
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{fullpage}
\usepackage{lscape}
\usepackage{graphicx}
\usepackage{stmaryrd}
\usepackage{upquote}

\newcommand{\enumstart}{\begin{enumerate}}
\newcommand{\enumend}{\end{enumerate}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\backtick}{\textasciigrave}
\newcommand{\ra}{$\rightarrow$}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\title{\textbf{Functional Programming Zusammenfassung}}
\author{Christoph Stillhard}
\date{}
\begin{document}

\maketitle
\pagenumbering{none}
\thispagestyle{empty}

\let\stdsection\section
\renewcommand\section{\newpage\stdsection}

\newpage
\pagenumbering{roman}
\setcounter{page}{1}
\tableofcontents

\newpage
\pagenumbering{arabic}
\setcounter{page}{1}

\section{Properties of Haskell}
\enumstart
	\item Side-effect free
	\item Functions are values
	\item Referential transparency (an expression evaluates to the same value in every context)
	\enumstart
		\item No assignments
		\item No global variables
	\enumend
	\item Recursion instead of iteration
	\item Flexible type system
	\enumstart
		\item Polymorphism supports reusability
	\enumend
	\item Lazy evaluation
	\enumstart
		\item Also called "call-by-need" or "left-most/outermost"
		\item Certain functions force evaluation
	\enumend
\enumend

\section{Syntax}
\enumstart
	\item Naming
	\enumstart
		\item Functions start with a lowercase letter
		\item Types start with an uppercase letter
	\enumend
	\item Language constructs
	\enumstart
		\item Function application
		\enumstart
			\item Function application by whitespace: $\langle$function$\rangle$ $\langle$argument$\rangle$
			\item Binary functions can be used infix by using backticks: $v_1$ \backtick function\backtick $v_2$
			\item An infix binary relation is called an operator
			\item An operator can be written prefix: (operator) $v_1 v_2$
			\item Operators have different binding strengths
		\enumend
		\item Guards
		\enumstart
			\item xor $x$ $y$\\ $.\ \ \ | x ==$ True $=$ not $y$\\ $.\ \ \ | x ==$ False $= y$
		\enumend
		\item Pattern matching
		\enumstart
			\item xor True $y$ = not $y$\\xor False $y$ = $y$
		\enumend
		\item Global scope functions
		\enumstart
			\item f $x$ $y$ = $\mathellipsis$
		\enumend
		\item Local scope functions
		\enumstart
			\item Let (builds one expression from others)
			\enumstart
				\item let x1 = e1\\$\vdots$\\.$\ \ \ \ $xn = en\\in e
			\enumend
			\item Where
			\enumstart
				\item f p1 p2 $\mathellipsis$ pm\\.$\ \ \ |$ g1 = e1\\$\vdots$\\.$\ \ \ |$ gk = ek\\.$\ \ \ $where\\.$\ \ \ \ \ $v1 a1 $\mathellipsis$ an = r1\\.$\ \ \ \ \ $v2 = r2
			\enumend
		\enumend
	\enumend
\enumend

\section{Types}
\enumstart
	\item Haskell is strongly typed $\rightarrow$ avoids runtime errors
	\item Either programmer provides types along with the function definition or system computes types itself
	\item Function-/argument-types must match
	\item Basic types
	\enumstart
		\item Int
		\enumstart
			\item Range: at least $\{-2^{29}, \mathellipsis, 2^{29}-1\}$
		\enumend
		\item Integer
		\enumstart
			\item Range: $\N$
		\enumend
		\item Bool
		\enumstart
			\item Values: True, False
		\enumend
		\item Char
		\enumstart
			\item Values: 'a', 'b', $\mathellipsis$, '0', '1', $\mathellipsis$, '$\backslash$t', '$\backslash$n'
		\enumend
		\item String
		\enumstart
			\item Strings are equivalent zu [Char]
			\item Special notation: "text" = ['t', 'e', 'x', 't']
		\enumend
		\item Float
		\enumstart
			\item Values: 0.3348, -2.34e07, $\mathellipsis$
		\enumend
		\item tuples
		\enumstart
			\item Is a type constructor
			\item $(t_1, \mathellipsis, t_n)$ is a type if $t_1, \mathellipsis, t_n$ are types and $n \ge 2$
		\enumend
	\enumend
\enumend


\end{document}